{
  "designDoc": "```markdown\n# Design Document: Minecraft Control Panel (MCP) Server with Bun\n\n## 1. Project Overview\n\nThis document outlines the design for a Minecraft Control Panel (MCP) server built using Bun. The MCP server will provide a web interface and API for managing Minecraft server instances, including starting, stopping, updating, and configuring servers. The goal is to create a performant, lightweight, and developer-friendly solution leveraging Bun's speed and modern JavaScript/TypeScript capabilities.\n\n**Key Features:**\n\n*   **Server Management:** Start, stop, restart Minecraft servers.\n*   **Configuration Management:** Edit server properties files and other configuration files.\n*   **User Authentication & Authorization:** Secure access to the control panel with user accounts and roles.\n*   **Monitoring:** Real-time monitoring of server resource usage (CPU, memory).\n*   **Plugin Management:** (Future) Install, uninstall, and manage Minecraft server plugins.\n*   **Backup & Restore:** (Future) Schedule and manage server backups.\n*   **Web Interface:** Intuitive web interface for easy server management.\n*   **API:** RESTful API for programmatic access and integration.\n\n**Target Audience:**\n\n*   Minecraft server administrators\n*   Minecraft hosting providers\n*   Developers building Minecraft-related applications\n\n## 2. Tech Stack\n\n**Core Technologies:**\n\n*   **Runtime Environment:** **Bun** - Chosen for its speed, built-in support for TypeScript, and compatibility with Node.js APIs. Bun's performance will be crucial for handling multiple Minecraft server instances and real-time monitoring.\n*   **Web Framework:** **Hono** - A lightweight, fast web framework for Bun and Node.js. Hono's simplicity and performance make it an excellent choice for building the API and serving static assets. It avoids unnecessary bloat found in larger frameworks.\n*   **Database:** **SQLite** (with **better-sqlite3** driver for Bun) - A lightweight, file-based database ideal for storing user accounts, server configurations, and other metadata. SQLite is easy to set up and manage, and its performance is sufficient for the project's needs. Alternatively, **PostgreSQL** could be considered for scalability if the user base grows significantly, using a driver like **postgres.js**.\n*   **ORM (Optional):** **Prisma** - If PostgreSQL is chosen, Prisma can be used to simplify database interactions and provide type-safe queries. If SQLite is selected, a lighter ORM or direct database queries can be used.\n*   **Authentication:** **JWT (JSON Web Tokens)** - For secure authentication and authorization.  Libraries like `jose` or custom implementation.\n*   **Frontend:** **Svelte/SvelteKit** - A modern JavaScript framework with a focus on performance and developer experience. Svelte compiles components to vanilla JavaScript at build time, resulting in smaller bundle sizes and faster rendering. Alternative: **React** or **Vue.js**, if preferred, but consider SvelteKit for its server-side rendering capabilities.\n*   **UI Library:** **Tailwind CSS** - A utility-first CSS framework for rapid UI development. Tailwind CSS provides a set of pre-defined CSS classes that can be used to style HTML elements without writing custom CSS.\n*   **Process Management:**  Bun's built-in `child_process` API (or a wrapper around it) will be used to manage Minecraft server processes.\n*   **Real-time Monitoring:** System metrics can be gathered using built-in OS tools (like `top` or `ps`) and exposed via the API.  Consider using a library that simplifies system monitoring (e.g., `systeminformation`).\n*   **Configuration Management:**  `dotenv` (or Bun's built-in environment variable support) for managing sensitive configuration values (API keys, database credentials).\n\n**Justification:**\n\n*   **Bun:** Performance is critical for managing Minecraft servers. Bun offers a significant speed advantage over Node.js.\n*   **Hono:**  Provides a streamlined and fast web framework tailored for Bun.\n*   **SQLite/PostgreSQL:** Provides robust data storage. SQLite for ease, PostgreSQL for scalability.\n*   **Svelte/SvelteKit:** Delivers a fast and efficient frontend with a great developer experience.\n*   **Tailwind CSS:** Enables rapid UI development with a consistent design language.\n\n## 3. Core Logic Flow (Mermaid Diagram)\n\n```mermaid\ngraph LR\n    subgraph User\n    A[User Web Browser]\n    B[User API Client]\n    end\n\n    subgraph MCP Server (Bun)\n    C(Hono Router)\n    D(Authentication/Authorization)\n    E(API Endpoints)\n    F(Database Interaction (SQLite/PostgreSQL))\n    G(Minecraft Process Manager)\n    H(System Monitoring)\n    end\n\n    subgraph Minecraft Server\n    I(Minecraft Server Instance 1)\n    J(Minecraft Server Instance 2)\n    K(Minecraft Server Instance N)\n    end\n\n    A --> C\n    B --> C\n\n    C --> D\n    D --> E\n\n    E --> F\n    E --> G\n    E --> H\n\n    G --> I\n    G --> J\n    G --> K\n\n    H --> I\n    H --> J\n    H --> K\n\n    F --> Database((Database))\n    Database --> F\n    style Database fill:#f9f,stroke:#333,stroke-width:2px\n\n    I --> System((System Resources))\n    J --> System\n    K --> System\n\n    H --> System\n\n    style System fill:#ccf,stroke:#333,stroke-width:2px\n```\n\n**Diagram Explanation:**\n\n1.  **User Interaction:** Users interact with the MCP server through a web browser (A) or an API client (B).\n2.  **Hono Router:** The Hono router (C) receives requests and routes them to the appropriate API endpoints.\n3.  **Authentication/Authorization:** The authentication/authorization module (D) verifies user credentials and permissions before allowing access to protected resources.\n4.  **API Endpoints:** The API endpoints (E) handle requests for server management, configuration, and monitoring.\n5.  **Database Interaction:** The API endpoints interact with the database (F) to store and retrieve server configurations, user accounts, and other metadata.\n6.  **Minecraft Process Manager:** The Minecraft process manager (G) is responsible for starting, stopping, and restarting Minecraft server instances.  It interacts with individual Minecraft server processes (I, J, K).\n7.  **System Monitoring:** The system monitoring module (H) collects resource usage data from the Minecraft servers (CPU, memory) and the overall system, and exposes it via the API.\n8. **Database:**  Persistent storage for server configurations, user data, etc.\n9. **System Resources:** Represents the underlying OS resources used by the Minecraft server instances and monitored by the monitoring module.\n\n\n## Implementation Expert Notes\nOkay, let's break down state management for an \"mcp server with bun\" project.  Since \"mcp server\" is a bit vague, I'll assume it means a multi-component or multi-client service, potentially managing data and interactions between those components/clients. The choice of Bun.js suggests a focus on speed and modern JavaScript tooling.  Here's a comprehensive overview with different options, ranging from simple to more robust:\n\n**Understanding the Requirements**\n\nBefore diving into code, let's identify potential state management needs. This will drive the choice of the right tool:\n\n*   **Global Configuration:** Server settings (ports, database connections, API keys).\n*   **User Sessions:** If the server handles user authentication and sessions, you'll need to manage user data and authentication status.\n*   **Real-time Data:** If the server handles real-time data (e.g., chat messages, sensor readings), you'll need a solution that supports efficient updates and synchronization.\n*   **Component State:** If your server comprises multiple modules or components, each might have its own local state (e.g., caching frequently accessed data, tracking active connections).\n*   **Persistence:**  How data is stored and retrieved (using a database, files, or other means).\n\n**State Management Options**\n\nHere's a breakdown of various state management strategies with code examples:\n\n**1. Simple Global Variables (Suitable for Small Projects)**\n\nFor very simple projects with minimal state, you can use global variables within your Bun.js server.\n\n```typescript\n// server.ts\n\nlet serverConfig = {\n    port: 3000,\n    databaseUrl: \"mongodb://localhost:27017/mydb\",\n    apiKey: \"your_secret_api_key\"\n};\n\nlet connectedClients: string[] = []; // Example: Array of client IDs\n\nfunction updateConfig(newConfig: Partial<typeof serverConfig>) {\n    serverConfig = { ...serverConfig, ...newConfig };\n    console.log(\"Config updated:\", serverConfig);\n}\n\nBun.serve({\n    port: serverConfig.port,\n    fetch(req) {\n        if (req.url.endsWith(\"/config\")) {\n            return new Response(JSON.stringify(serverConfig));\n        }\n        if(req.url.endsWith(\"/updateConfig\")){\n            updateConfig({port: 3001});\n            return new Response(\"Config updated to port 3001\");\n        }\n        return new Response(\"Hello from Bun!\");\n    },\n});\n\nconsole.log(`Server running at http://localhost:${serverConfig.port}`);\n```\n\n**Explanation:**\n\n*   `serverConfig`:  A simple object to hold server configuration.\n*   `connectedClients`: An array used to store connected clients.\n*   `updateConfig`:  A function to safely update the config.\n*   Access through `serverConfig.port`, `serverConfig.databaseUrl`, etc.\n\n**Pros:**\n\n*   Easy to implement for basic scenarios.\n*   No external dependencies.\n\n**Cons:**\n\n*   Difficult to manage complex state.\n*   Can lead to unpredictable behavior if not carefully controlled.\n*   Not suitable for larger applications.\n*   No built-in reactivity or change detection.\n\n**2. Modules with Exported State (Improved Organization)**\n\nA slightly better approach is to encapsulate state within modules and export getter/setter functions.\n\n```typescript\n// config.ts\n\nlet config = {\n    port: 3000,\n    databaseUrl: \"mongodb://localhost:27017/mydb\",\n    apiKey: \"your_secret_api_key\"\n};\n\nexport function getConfig() {\n    return { ...config }; // Return a copy to prevent direct modification.\n}\n\nexport function setConfig(newConfig: Partial<typeof config>) {\n    config = { ...config, ...newConfig };\n    console.log(\"Config updated:\", config);\n}\n\n// server.ts\nimport { getConfig, setConfig } from \"./config\";\n\nBun.serve({\n    port: getConfig().port,\n    fetch(req) {\n        if (req.url.endsWith(\"/config\")) {\n            return new Response(JSON.stringify(getConfig()));\n        }\n        if(req.url.endsWith(\"/updateConfig\")){\n            setConfig({port: 3001});\n            return new Response(\"Config updated to port 3001\");\n        }\n        return new Response(\"Hello from Bun!\");\n    },\n});\n\nconsole.log(`Server running at http://localhost:${getConfig().port}`);\n```\n\n**Explanation:**\n\n*   `config.ts`: Encapsulates the configuration state and provides controlled access through `getConfig` and `setConfig`.  Returning a copy in `getConfig` is important to prevent accidental direct modification of the internal state.\n*   `server.ts`: Imports the getter/setter functions to access and modify the config.\n\n**Pros:**\n\n*   Better organization than simple global variables.\n*   Controlled access to state.\n\n**Cons:**\n\n*   Still lacks reactivity. Changes aren't automatically reflected elsewhere.\n*   Can become complex with many modules and dependencies.\n\n**3.  Reactive State Management with `nanostores`**\n\nFor applications requiring more dynamic updates and reactivity, consider a lightweight state management library like `nanostores`.\n\n```typescript\n// store.ts\nimport { atom, map } from 'nanostores';\n\n// Simple atom for a single value\nexport const port = atom(3000);\n\n// Store for multiple values (like a configuration object)\nexport const config = map({\n  databaseUrl: \"mongodb://localhost:27017/mydb\",\n  apiKey: \"your_secret_api_key\"\n});\n\nexport function setConfig(newConfig: Partial<typeof config.value>) {\n  config.set({ ...config.value, ...newConfig });\n}\n\n\n// server.ts\nimport { port, config, setConfig } from './store';\n\nBun.serve({\n    port: port.get(),\n    fetch(req) {\n        if (req.url.endsWith(\"/config\")) {\n            return new Response(JSON.stringify(config.get()));\n        }\n        if(req.url.endsWith(\"/updateConfig\")){\n            setConfig({databaseUrl:\"new_db_url\"});\n            return new Response(\"Config updated.\");\n        }\n        return new Response(\"Hello from Bun!\");\n    },\n});\n\nconsole.log(`Server running at http://localhost:${port.get()}`);\n\n```\n\n**Explanation:**\n\n*   `nanostores` is a tiny state management library with a minimal API.\n*   `atom`: Represents a single, mutable value.\n*   `map`: Represents a mutable object (key-value pairs).\n*   `port.get()`: Retrieves the current value of the `port` atom.\n*   `config.set()`: Updates the entire `config` map.  For partial updates, use the spread operator as shown in `setConfig`.\n*   (Not demonstrated here, but you can subscribe to changes in atoms and maps to trigger updates in other parts of your application.)\n\n**Pros:**\n\n*   Lightweight and fast.\n*   Reactive updates.\n*   Simple API.\n*   Good for small to medium-sized projects.\n\n**Cons:**\n\n*   Less feature-rich than larger state management libraries.\n*   May require more manual handling of complex state relationships.\n\n**4.  Context API (If Used in a Framework Like Elysia or Hono)**\n\nIf you're using a framework like Elysia or Hono, you can leverage their context/dependency injection mechanisms for state management.  This approach tightly integrates state with the framework's request lifecycle.\n\n**Example with Elysia.js**\n\n```typescript\n// server.ts\nimport { Elysia } from \"elysia\";\n\nconst app = new Elysia()\n  .decorate(\"config\", {\n    port: 3000,\n    databaseUrl: \"mongodb://localhost:27017/mydb\"\n  })\n  .get(\"/config\", ({ config }) => config)\n  .listen(3000);\n\nconsole.log(\n  `ü¶ä Elysia is running at ${app.server?.hostname}:${app.server?.port}`\n);\n\n```\n\n**Explanation:**\n\n*   `app.decorate(\"config\", ...)`: Registers a `config` property on the Elysia context, making it accessible within route handlers.\n\n**Pros:**\n\n*   Tight integration with the framework.\n*   Simplified dependency injection.\n\n**Cons:**\n\n*   Framework-specific.\n*   May not be suitable for complex state management needs outside of the request lifecycle.\n\n**5. Database as State (Persistent State Management)**\n\nFor persistent state, use a database such as PostgreSQL, MongoDB, or SQLite.\n\n```typescript\n// database.ts (Example using SQLite with Better SQLite3)\nimport Database from 'better-sqlite3';\n\nconst db = new Database('mydb.db');\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS settings (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    key TEXT UNIQUE,\n    value TEXT\n  )\n`);\n\nexport function getSetting(key: string): string | undefined {\n  const stmt = db.prepare('SELECT value FROM settings WHERE key = ?');\n  const row = stmt.get(key) as { value: string } | undefined;\n  return row?.value;\n}\n\nexport function setSetting(key: string, value: string) {\n  const stmt = db.prepare('INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)');\n  stmt.run(key, value);\n}\n\n// server.ts\nimport { getSetting, setSetting } from './database';\n\nconst port = parseInt(getSetting('port') || '3000'); // Default port\nconsole.log(\"Port from db:\", port)\n\nBun.serve({\n    port: port,\n    fetch(req) {\n        if (req.url.endsWith(\"/config\")) {\n          const config = {\n            port: getSetting('port'),\n            // ... other settings\n          }\n            return new Response(JSON.stringify(config));\n        }\n        if(req.url.endsWith(\"/updatePort\")){\n          setSetting(\"port\", \"3001\")\n          return new Response(\"Port updated to 3001. Restart the server to apply the changes.\");\n        }\n        return new Response(\"Hello from Bun!\");\n    },\n});\n\nconsole.log(`Server running at http://localhost:${port}`);\n```\n\n**Explanation:**\n\n*   `database.ts`: Handles database interactions.\n*   `getSetting`, `setSetting`: Functions to retrieve and update settings in the database.\n*   Server retrieves the port from the database on startup.\n\n**Pros:**\n\n*   Persistent storage of state.\n*   Suitable for managing user data, application settings, and other persistent data.\n\n**Cons:**\n\n*   Adds complexity to the project.\n*   Requires database setup and management.\n\n**Choosing the Right Approach**\n\n*   **Very Small Projects:** Simple global variables or modules with exported state might be sufficient.\n*   **Medium-Sized Projects with Reactive Updates:** `nanostores` is a good choice.\n*   **Projects Using Frameworks:** Leverage the framework's context API or dependency injection.\n*   **Projects Requiring Persistent State:** Use a database.\n*   **Complex State Management:** Consider more robust libraries like Zustand or Jotai (although these might be overkill for simpler server-side projects).\n\n**Important Considerations**\n\n*   **Immutability:** Favor immutable state updates to prevent unexpected side effects.\n*   **Concurrency:** Be mindful of concurrency issues when updating state in a multi-threaded environment.  Use appropriate synchronization mechanisms if needed.\n*   **Testing:** Write unit tests to ensure your state management logic is working correctly.\n*   **Scalability:**  If you anticipate scaling your server, choose a state management solution that can handle increased load and complexity.\n\nThis guide should give you a solid foundation for managing state in your Bun.js \"mcp server\" project. Adapt these strategies to your specific needs, and remember to prioritize simplicity and maintainability.\n\n\n## üõ°Ô∏è Security Audit (Guardian)\n# Security Audit Report: MCP Server with Bun\n\n## Security Score: 55%\n\n## Detected Vulnerabilities\n\n*   **Authentication/Authorization:**\n    *   **Missing Implementation:** The design document mentions JWT for authentication, but no server-side code is provided. This means authentication is currently non-existent, leaving all API endpoints unprotected.\n    *   **Insecure Transport:** The provided React code uses `http://localhost:3000` as the default server URL. In a production environment, this MUST be `https://` to prevent man-in-the-middle attacks. The design doc also doesn't explicitly state that HTTPS should be used.\n\n*   **API Vulnerabilities:**\n    *   **Lack of Input Validation/Sanitization:** The `executeCommand` function in `src/utils/api.ts` and the implied server-side endpoint receiving this command, lacks input validation and sanitization. This is a major risk for command injection vulnerabilities. A malicious user could inject arbitrary commands into the server.\n    *   **Missing Rate Limiting:** No rate limiting is implemented on API endpoints. This could lead to denial-of-service (DoS) attacks by flooding the server with requests.\n\n*   **Configuration Management:**\n    *   **Hardcoded Server URL in Client:** `src/App.tsx` and `src/utils/api.ts` contain hardcoded server URLs (`http://localhost:3000`). This is bad practice and could lead to deployment issues and security risks. It should be configured via environment variables on both client *and* server.  The design doc correctly mentions using `dotenv` but this isn't applied in the frontend.\n    *   **Environment Variable Security:** While the design document mentions `dotenv`, it doesn't specify *how* these environment variables will be managed and secured in a production environment (e.g., using a secrets management system).\n\n*   **Process Management:**\n    *   **Missing Security Context:** The design and code doesn't specify under what user the Minecraft server processes run. Running them as `root` or a user with excessive privileges is a major security risk. If the Minecraft server is compromised, the attacker gains those privileges.\n    *   **Insufficient Resource Limits:** No resource limits (CPU, memory, disk I/O) are defined for the Minecraft server processes. This could lead to resource exhaustion and affect the performance of the entire system.\n\n*   **Monitoring:**\n    *   **Lack of Security Monitoring:** While the design mentions system monitoring, it doesn't specify any security-specific monitoring (e.g., intrusion detection, anomaly detection).\n\n*   **Frontend:**\n    *   **XSS Vulnerabilities:** The `ConsoleOutput` component renders unsanitized console output. If the Minecraft server or its plugins output malicious JavaScript code, it could be executed in the user's browser, leading to cross-site scripting (XSS) vulnerabilities.\n\n*   **Database:**\n    *   **SQL Injection (Potential):** While the design document mentions SQLite or PostgreSQL, no database interaction code is provided in the available files. *IF* the database interaction isn't properly parameterized (using prepared statements or an ORM that handles escaping), the application is highly vulnerable to SQL injection.\n\n## Hardening Instructions\n\n*   **Implement Robust Authentication/Authorization:**\n    *   **Mandatory JWT Implementation:** Implement JWT-based authentication for all API endpoints, as described in the design document. Use a well-vetted library like `jose` or similar. Verify JWTs on every request to protected routes.\n    *   **HTTPS Enforcement:** Enforce HTTPS for all communication between the client and the server. Obtain and configure TLS certificates properly. Redirect HTTP traffic to HTTPS. Configure Hono to use HTTPS.\n    *   **Secure Credential Storage:** *Never* store passwords in plain text. Use bcrypt or Argon2 to hash passwords before storing them in the database.\n\n*   **Sanitize and Validate User Input:**\n    *   **Command Injection Prevention:** Implement strict input validation and sanitization for the `command` parameter in the `executeCommand` function and corresponding server-side endpoint.  Use a whitelist of allowed commands and parameters.  *Never* directly pass user input to the underlying shell without escaping/sanitization.  Consider using a dedicated library for command execution with proper escaping.\n    *   **General Input Validation:**  Validate all user input on the server-side. Use strong data type checking, length limits, and regular expressions to ensure that the data is valid and safe.\n\n*   **Implement Rate Limiting:**\n    *   **API Rate Limiting:** Implement rate limiting on all API endpoints to prevent DoS attacks. Use a middleware to limit the number of requests from a single IP address or user within a given time frame. Libraries are available for Hono to assist with this.\n\n*   **Secure Configuration Management:**\n    *   **Environment Variable Best Practices:** Use environment variables for *all* configuration parameters, including API keys, database credentials, and server URLs.\n    *   **Secrets Management:** For production deployments, store sensitive environment variables (secrets) in a dedicated secrets management system (e.g., HashiCorp Vault, AWS Secrets Manager, Google Cloud Secret Manager).  *Never* commit secrets to version control.\n    *   **Remove Hardcoded URLs:** Replace the hardcoded server URLs in `src/App.tsx` and `src/utils/api.ts` with environment variables (e.g., `REACT_APP_SERVER_URL`).\n\n*   **Harden Process Management:**\n    *   **Least Privilege Principle:** Run the Minecraft server processes under a dedicated user account with *minimal* privileges.  *Never* run them as `root`.\n    *   **Resource Limits:**  Set resource limits (CPU, memory, disk I/O) for the Minecraft server processes using `ulimit` or similar tools.  Consider using containerization (Docker) to further isolate the server processes.\n    *   **Sandboxing:** Explore process sandboxing techniques to further restrict the capabilities of the Minecraft server processes.\n\n*   **Enhance Monitoring:**\n    *   **Security Monitoring:** Implement security-specific monitoring to detect intrusions, anomalies, and other suspicious activities.  Use a security information and event management (SIEM) system to collect and analyze security logs.\n    *   **Log Auditing:**  Enable detailed logging of all server activity and regularly audit the logs for security issues.\n\n*   **Address Frontend Vulnerabilities:**\n    *   **XSS Sanitization:** Sanitize the console output before rendering it in the `ConsoleOutput` component. Use a library like DOMPurify or similar to remove any potentially malicious JavaScript code.  *Never* blindly trust the output from the Minecraft server.\n\n*   **Secure Database Interactions:**\n    *   **Parameterized Queries:** *Always* use parameterized queries (prepared statements) to interact with the database.  This prevents SQL injection vulnerabilities.  If using an ORM, ensure that it handles parameterization correctly.\n    *   **Principle of Least Privilege (Database):** Grant the database user used by the application only the *minimum* required privileges.\n\n*   **Missing CSRF Protection:** The design and current code base doesn't appear to take into account any CSRF protection. Implement CSRF protection for all state-changing operations.\n",
  "structure": {
    "src": {
      "components": {
        "Header.tsx": "Component for the header of the application.",
        "ServerStatus.tsx": "Component displaying the server status.",
        "ConsoleOutput.tsx": "Component for displaying console output.",
        "CommandInput.tsx": "Component for taking command input from the user."
      },
      "utils": {
        "api.ts": "Utility functions for interacting with the server API."
      },
      "App.tsx": "Main application component.",
      "index.tsx": "Entry point for the React application."
    },
    "public": {
      "index.html": "Main HTML file."
    },
    "package.json": "Package definition.",
    "tsconfig.json": "TypeScript configuration."
  },
  "code": {
    "src/components/Header.tsx": "import React from 'react';\n\ninterface HeaderProps {\n  title: string;\n}\n\nconst Header: React.FC<HeaderProps> = ({ title }) => {\n  return (\n    <header style={{ backgroundColor: '#333', color: 'white', padding: '1rem' }}>\n      <h1>{title}</h1>\n    </header>\n  );\n};\n\nexport default Header;",
    "src/components/ServerStatus.tsx": "import React, { useState, useEffect } from 'react';\nimport { getServerStatus } from '../utils/api';\n\ninterface ServerStatusProps {\n  serverUrl: string;\n}\n\nconst ServerStatus: React.FC<ServerStatusProps> = ({ serverUrl }) => {\n  const [status, setStatus] = useState<string>('Loading...');\n\n  useEffect(() => {\n    const fetchStatus = async () => {\n      try {\n        const data = await getServerStatus(serverUrl);\n        setStatus(data.status);\n      } catch (error) {\n        setStatus('Offline');\n      }\n    };\n\n    fetchStatus();\n\n    const intervalId = setInterval(fetchStatus, 5000); // Poll every 5 seconds\n\n    return () => clearInterval(intervalId); // Cleanup interval on unmount\n  }, [serverUrl]);\n\n  return (\n    <div style={{ padding: '1rem', border: '1px solid #ccc' }}>\n      <h2>Server Status</h2>\n      <p>Status: {status}</p>\n    </div>\n  );\n};\n\nexport default ServerStatus;",
    "src/components/ConsoleOutput.tsx": "import React from 'react';\n\ninterface ConsoleOutputProps {\n  output: string;\n}\n\nconst ConsoleOutput: React.FC<ConsoleOutputProps> = ({ output }) => {\n  return (\n    <div style={{ padding: '1rem', border: '1px solid #ccc', whiteSpace: 'pre-wrap', fontFamily: 'monospace' }}>\n      <h2>Console Output</h2>\n      <p>{output}</p>\n    </div>\n  );\n};\n\nexport default ConsoleOutput;",
    "src/components/CommandInput.tsx": "import React, { useState } from 'react';\nimport { executeCommand } from '../utils/api';\n\ninterface CommandInputProps {\n  serverUrl: string;\n  onCommandExecuted: () => void; // Callback to signal a command was executed\n}\n\nconst CommandInput: React.FC<CommandInputProps> = ({ serverUrl, onCommandExecuted }) => {\n  const [command, setCommand] = useState<string>('');\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setCommand(event.target.value);\n  };\n\n  const handleSubmit = async (event: React.FormEvent) => {\n    event.preventDefault();\n    try {\n      await executeCommand(serverUrl, command);\n      setCommand('');\n      onCommandExecuted(); // Signal that a command has been executed\n    } catch (error) {\n      console.error('Error executing command:', error);\n    }\n  };\n\n  return (\n    <div style={{ padding: '1rem', border: '1px solid #ccc' }}>\n      <h2>Command Input</h2>\n      <form onSubmit={handleSubmit}>\n        <input\n          type=\"text\"\n          value={command}\n          onChange={handleChange}\n          placeholder=\"Enter command\"\n          style={{ width: '100%', padding: '0.5rem' }}\n        />\n        <button type=\"submit\" style={{ marginTop: '0.5rem', padding: '0.5rem 1rem' }}>Execute</button>\n      </form>\n    </div>\n  );\n};\n\nexport default CommandInput;",
    "src/utils/api.ts": "const SERVER_URL = process.env.SERVER_URL || 'http://localhost:3000';\n\nexport const getServerStatus = async (serverUrl: string) => {\n  const response = await fetch(`${serverUrl}/status`);\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  return response.json();\n};\n\nexport const executeCommand = async (serverUrl: string, command: string) => {\n  const response = await fetch(`${serverUrl}/command`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ command }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  return response.json();\n};\n",
    "src/App.tsx": "import React, { useState, useEffect } from 'react';\nimport Header from './components/Header';\nimport ServerStatus from './components/ServerStatus';\nimport ConsoleOutput from './components/ConsoleOutput';\nimport CommandInput from './components/CommandInput';\n\nconst App: React.FC = () => {\n  const [consoleOutput, setConsoleOutput] = useState<string>('');\n  const SERVER_URL = process.env.REACT_APP_SERVER_URL || 'http://localhost:3000';\n\n  const handleCommandExecuted = async () => {\n    // Fetch the latest console output from the server\n    try {\n      const response = await fetch(`${SERVER_URL}/console`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      setConsoleOutput(data.output);\n    } catch (error) {\n      console.error('Error fetching console output:', error);\n    }\n  };\n\n  useEffect(() => {\n    handleCommandExecuted();\n  }, []);\n\n  return (\n    <div>\n      <Header title=\"MCP Server Control\" />\n      <ServerStatus serverUrl={SERVER_URL} />\n      <ConsoleOutput output={consoleOutput} />\n      <CommandInput serverUrl={SERVER_URL} onCommandExecuted={handleCommandExecuted} />\n    </div>\n  );\n};\n\nexport default App;",
    "src/index.tsx": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n",
    "public/index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>MCP Server Control</title>\n</head>\n<body>\n    <div id=\"root\"></div>\n</body>\n</html>",
    "package.json": "{\n  \"name\": \"mcp-server-control\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"^18.0.0\",\n    \"react-dom\": \"^18.0.0\",\n    \"@types/react\": \"^18.0.0\",\n    \"@types/react-dom\": \"^18.0.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^4.0.0\",\n    \"@types/node\": \"^16.0.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"eslintConfig\": {\n    \"extends\": [\"react-app\", \"react-app/jest\"]\n  },\n  \"browserslist\": {\n    \"production\": [\">0.2%\", \"not dead\", \"not op_mini all\"],\n    \"development\": [\"last 1 chrome version\", \"last 1 firefox version\", \"last 1 safari version\"]\n  }\n}",
    "tsconfig.json": "{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\"\n  },\n  \"include\": [\"src\"]\n}"
  }
}